Trees have a useful structure for storing and searching data. They are often used when you want to express hierarchical structures. Let's learn together.

> [!NOTE] Fields Where Trees Are Used
>
> - Artificial Intelligence: Decision trees are used when creating judgment criteria for AI.
> - Autocomplete Features: Trees are also used a lot in string processing. Search engines also use a tree structure called trie for autocomplete search suggestions.
> - Databases: Trees are used to structure and index data so it can be easily searched, inserted, and deleted. B-trees or B+ trees are often used.

# Concept

A tree is a data structure shaped like an upside-down tree with branches extending from the trunk.

![](/images/2025-06-21/Pasted%20image%2020250621101921.png)
Various terms exist. Let's learn them one by one.

## Structure

### Nodes That Make Up a Tree

A node is an element that makes up a tree, and the node at the top is called the root node. In the picture above, the node with value 1 is the root node.

#### Nodes with Parent-Child and Sibling Relationships

Family-related terms are sometimes used.

- Nodes with the same parent node: **sibling nodes**
- If there is a node below a specific node in the tree, the specific node is the **parent node**, and the node below is the **child node**.

#### Terminal Nodes Without Children

Nodes without children are called **leaf nodes**.

### Edges That Connect Nodes

The lines connecting nodes are called **edges** or **edges**.

Trees have nodes connected by unidirectional edges, and the path from the root node to each node is unique.

The minimum number of edges traversed from the root node to a specific node is expressed as **level**. (Root is 0, then 1, 2, 3, 4...)

#### Number of Downward Edges, Degree

The number of edges going downward from a specific node is called **degree**. Node 1 can be said to have degree 3.

# Binary Tree Implementation

A tree where the maximum degree of all nodes does not exceed 2 is called a **binary tree**.

![](/images/2025-06-21/Pasted%20image%2020250621105144.png)
There are two ways to implement it.

- Using arrays
- Using pointers

Let's get more familiar with trees by implementing a binary tree.

## Implementation Using Arrays

Arrays are linear data structures, and trees are hierarchical data structures. To express a tree with an array, the following three rules are needed.

1. **Root node** is stored at array index **1**.
2. **Left** child node's array index is **parent node's array index × 2**.
3. **Right** child node's array index is **parent node's array index × 2 + 1**.

Implementing according to the above rules looks like this.
![](/images/2025-06-21/Pasted%20image%2020250621105442.png)

Looking at just the indices, they increase like 1, 2, 4, 8, with index increasing as `parent × 2`. Following the dotted arrows, you can see indices flowing like 1, 3, 7. You can see it increases as `parent × 2 + 1`.

![](/images/2025-06-21/Pasted%20image%2020250621105813.png)

If you set the root node to 0, the left child node is `parent × 2 + 1` and the right child node is `parent × 2 + 2`.

You might think implementing with arrays is enough. But implementing with arrays inevitably creates empty indices, like indices 9, 10, 11, 12, 13 being empty for index 14 in the picture above.

> When a binary tree has N nodes, creating a binary tree with an array takes O(N).

## Implementation Using Pointers

In a tree implemented with pointers, a node has the node's value, left child node, and right child node.

![](/images/2025-06-21/Pasted%20image%2020250621111301.png)

Trees implemented with pointers don't waste memory space like arrays because they don't perform index operations.
![](/images/2025-06-21/Pasted%20image%2020250621111338.png)

You implement by creating one node through the class below and connecting them with left and right properties.

```ts
class Node(){
  constructor(value){
    this.value = value;
    this.left = null;
    this.right = null;
  }
}
```

# Traversing Binary Trees

Visiting a specific data structure without missing anything is called **traversal**. In terms of arrays, traversal is needed when searching for specific data using array indices. There are a total of 3 methods for tree traversal

Simply explained, they are as follows.

- Preorder Traversal: Visit in order: value > left child > right child
- Inorder Traversal: Visit in order: left child > value > right child
- Postorder Traversal: Visit in order: left child > right child > value
  Let's learn in more detail.

## Preorder Traversal

Visit in order: current node > left child node > right child node.

> [!NOTE] Visit
>
> In traversal, "visit" means the state where traversal is complete. The term "visit" is used to distinguish between passing by and not passing by during traversal. In the following picture, one house was just passed by, and the other two houses have completed visits.
>
> ![](/images/2025-06-21/Pasted%20image%2020250622145855.png)

Let's say we're doing a preorder traversal of the array below.

```ts
const a = [null, 1, 4, 8, 3, 5, null, 7, 2, null, null, null, 6, null];
```

Since it's a tree assuming index 1 as root, drawn as a picture it looks like this.
![](/images/2025-06-21/Pasted%20image%2020250622145125.png)

Let's start traversal from the root. Since it's current node > left child > right child, we mark the root and start.

![](/images/2025-06-21/Pasted%20image%2020250622144957.png)
Return value: 1

Then go to the left child node and traverse again. Now 4 becomes the current node.
![](/images/2025-06-21/Pasted%20image%2020250622145209.png)
Return value: 1, 4

Continue traversing in the same way until you meet 2, which has no children.
![](/images/2025-06-21/Pasted%20image%2020250622145326.png)
Return value: 1, 4, 3, 2

Go back up and traverse 5, the right child of the most recent node.
![](/images/2025-06-21/Pasted%20image%2020250622145418.png)
Return value: 1, 4, 3, 2, 5

Traverse the entire tree in this way.
![](/images/2025-06-21/Pasted%20image%2020250622145427.png)
Return value: 1, 4, 3, 2, 5, 8, 7, 6

This traversal method is easy to understand intuitively because it visits (outputs) the current node first. It's a method often used when copying trees.

## Inorder Traversal

Visit in order: left child node > current node > right child node. It's a method that just passes through the current node and goes down to the left node.

Let's traverse the same tree as preorder traversal.

Starting from the root with value 1, go to the end node of the left child. At this time, since we're not "visiting," only 2 is returned.
![](/images/2025-06-21/Pasted%20image%2020250622150201.png)
Return value: 2

Since the order is left child > current node > right child, go back up from 2 (which was 3's left child) and traverse 3.
![](/images/2025-06-21/Pasted%20image%2020250622150244.png)
Return value: 2, 3

Go back up to the root in this way.
![](/images/2025-06-21/Pasted%20image%2020250622152000.png)
Return value: 2, 3, 4, 5, 1

Complete traversal by recursively going through left node, current node, right node again.
![](/images/2025-06-21/Pasted%20image%2020250622152148.png)
Return value: 2, 3, 4, 5, 1, 8, 6, 7

As additional information, this method is used when getting values in sorted order in binary search trees that will appear later, so you should know it well.

## Postorder Traversal

This is the last traversal method.

Visit in order: left child node > right child node > current node.

According to the rules, go to the end of the left child like inorder traversal. Since 2 has no left or right children, visit the current node 2.
![](/images/2025-06-21/Pasted%20image%2020250622152402.png)
Return value: 2

Going back up is the same as inorder traversal, but it changes a bit at 4. 4 is a node with both left and right children. That is, if the left child 3 has been visited, the next order is the right child. That is, 5 is visited before 4.
![](/images/2025-06-21/Pasted%20image%2020250622152456.png)
Return value: 2, 3, 5

The same phenomenon occurs at the root.
![](/images/2025-06-21/Pasted%20image%2020250622152626.png)
Return value: 2, 3, 5, 4, 6

When the root is finally visited, traversal ends.
![](/images/2025-06-21/Pasted%20image%2020250622152729.png)
Return value: 2, 3, 5, 4, 6, 7, 8, 1

When deleting nodes, you shouldn't delete the parent first. You need to delete child nodes first to delete up to the root node recursively while maintaining the tree. So the characteristic of postorder traversal of visiting child nodes first is often used in tree deletion.

# Binary Search Tree

A binary tree with a unique sorting method that places values smaller than the current node to the left child position and values greater than or equal to the right child position based on data size

## Searching Binary Trees

The good thing about trees is that they can be designed to search efficiently.

You can give specific rules to binary trees with a maximum of 2 child nodes to use them for your purpose. Let's learn about one of them, the binary search tree.

The rule of a binary search tree is "Place values smaller than the current node to the left child position and values greater than or equal to the right child position based on data size."

Let's put the following array into a binary search tree.

```ts
const arr = [3, 4, 2, 8, 9, 7, 1];
```

The first data becomes the root node. It becomes a tree with only 3.
![](/images/2025-06-21/Pasted%20image%2020250622153638.png)

Now place smaller values to the left and larger values to the right based on this. 4 is larger than 3, so it should be placed on the right.
![](/images/2025-06-21/Pasted%20image%2020250622153724.png)

This method happens recursively. If 3, 4, 2 are positioned based on 3, then from 8 onwards, the rules are applied recursively in the order 3 > 4. (It's not a rule like always from the third value. It's because 3's two child positions are both filled, so from 8 onwards it's applied recursively.)

![](/images/2025-06-21/Pasted%20image%2020250622153743.png)

Completing the binary search tree through this method looks like this.
![](/images/2025-06-21/Pasted%20image%2020250622153949.png)

Now searching based on this tree can be done in the following order.

1. Start from the root, move to the left child node if the value is smaller, and move to the right child node if the value is larger.
2. If a specific value is found, end the search.

You can tell it's very efficient just from the simple rules above without calculating. I'll cover detailed time complexity later.

### Difference from Array Search

![](/images/2025-06-21/Pasted%20image%2020250622154332.png)

In the above situation, when searching for 5 in an array, 7 comparison operations are needed. This is because you need to traverse the array until it appears.

Searching in a binary search tree in the same situation ends in just 2 times. (Search index order: 0 > 2 > 5, and since index 5 has no left child, you can confirm that 5 doesn't exist.)

### Time Complexity of Binary Search Tree

The time complexity of a binary search tree depends on tree balance. A balanced tree means that each node's degree is maintained similarly, and each node's number of child nodes is maintained similarly.

When balance is maintained, it can be said to be most ideal. The time complexity at the most ideal time is **O(logN)**. (This is because the tracking target is exactly halved during insertion and search.)

Conversely, if balance is not maintained, insertion and search operations have **O(N)** time complexity. This matches arrays.

Let's find out why.

#### Unbalanced Tree: Skewed Form Tree

degenerate binary tree
![](/images/2025-06-21/Pasted%20image%2020250622155353.png)

The rule of a binary search tree is that if the value you're looking for is smaller than the value you're currently searching, search the left child, otherwise search the right child, and if equal, end the search.

If it's unbalanced, this rule often becomes unnecessary. Because you'll only go in one direction. Thinking extremely, this becomes a structure no different from an array. That is, it has the same time complexity as arrays, O(N).

But this is just one case among many. If even one in the picture above moves to the opposite child of the root node, you could say performance is better than arrays.

#### Balanced Tree: Balanced Binary Search Tree

Balanced binary search trees are often called AVL trees, red-black trees, etc. in detail. Using these, the number of search operations is proportional to tree height, and since tree height is logN, search time complexity can be maintained at O(logN).

# References

https://product.kyobobook.co.kr/detail/S000213641007

> [!SUMMARY]
>
> Algorithm concepts seem to disappear particularly quickly if you don't study them consistently.
> I'll study consistently so I can fill them back in when they disappear.
> If there are any incorrect knowledge, please leave a comment!
>
> Thank you for reading.

