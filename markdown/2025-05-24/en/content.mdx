Arrays are a basic data type that can efficiently manage elements of the same type. You can group data of the same type under one variable name and access desired data randomly using something called an index.

Let's learn more about arrays.

# Array Declaration

Array declarations can be created using various methods.

```js
const arr = [0, 0, 0, 0, 0, 0]; // [0, 0, 0, 0, 0, 0]

const arr2 = new Array(6); // [empty Ã— 6]

const arr3 = [...new Array(6)].map((_) => 0); // [0, 0, 0, 0, 0, 0]

const arr4 = new Array(6).fill(0); // [0, 0, 0, 0, 0, 0]
```

Arrays refer to data structures stored in computers like this.

![](/images/2025-05-24/Pasted%20image%2020250615180237.png)

Starting from 0, to access the 3rd data, you use `arr[2]`.

JavaScript's Array object supports the same functionality as arrays. JavaScript arrays have different internal implementations than typical arrays, but you can think of them as having the same usage.

> [!NOTE] JavaScript Arrays
>
> JavaScript arrays are implemented to dynamically adjust size. So JavaScript arrays can use all the functionality of arrays from other languages while also being variable in size, which reduces considerations in coding tests. They also provide operations like slicing, insertion, deletion, and concatenation, making them more convenient.

# Arrays and Dimensions

Arrays exist in various dimensions. Since computer memory structure is one-dimensional, all are stored in one-dimensional space regardless of dimension. (They are allocated contiguously in memory.)

## One-Dimensional Array

![](/images/2025-05-24/Pasted%20image%2020250615181200.png)
The appearance of a one-dimensional array is the same as the actual array allocated in memory. Each data in the array is allocated consecutively from low addresses to high addresses in memory.

## Two-Dimensional Array

A two-dimensional array is an extension of a one-dimensional array. In JavaScript, it's declared as follows.

```js
// Literal
const arr = [
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9, 10, 11, 12],
];

// Implementing a 2D array using fill method and spread operator
const arr2 = [...new Array(3)].map((_, i) => new Array(3).fill(i));
// arr2: [[0, 0, 0], [1, 1, 1], [2, 2, 2]]
```

Two-dimensional arrays are stored in one-dimensional space in actual memory, allocating data in row order as shown in the right side of the picture below.

![](/images/2025-05-24/Pasted%20image%2020250615215144.png)

# Array Time Complexity

## Data Access

Arrays can access data at all positions in the array at once using a method called "random access."

```js
const arr = [1, 2, 3, 4];
arr[1]; // 2
```

It's constant (`O(1)`) regardless of the number of data items.

## Data Addition

When adding data, it differs depending on where you add it. This is related to memory.

### Insert at the End

![](/images/2025-05-24/Pasted%20image%2020250616080701.png)

When inserting data at the end, as shown in the picture, it doesn't affect the position of other data. Therefore, it's constant (`O(1)`) regardless of the number of data items.

### Insert in the Middle

![](/images/2025-05-24/Pasted%20image%2020250616080846.png)

If you insert data in the middle, you need to push operations for as many data items as there are behind it. (e.g., N-a items where N is the number of data items, and a is the number of existing data items in front of the insertion position) If the number of data items to push is N, the time complexity becomes `O(N)`.

### Insert at the Beginning

![](/images/2025-05-24/Pasted%20image%2020250616080759.png)

When inserting data at the beginning, you need to push existing data one space. Time complexity increases proportionally to the number of data items (`O(N)`)

In conclusion, arrays are good to use when you frequently need to access or read data. However, you need to consider that sufficient memory space must be secured. Usually, a one-dimensional integer array can handle up to 10 million items, and a two-dimensional array can handle up to 3000 * 3000 size. Also, you need to check if there are many data insertions in the middle. If data is frequently inserted in the middle or at the beginning, time complexity becomes high (`O(N)` time complexity)

> [!NOTE] Difference from Lists
>
> Lists are data structures with variable size, and arrays have fixed size. JavaScript arrays are dynamic arrays, so they can change size and can also be treated as lists.

# Array Manipulation

## Data Addition

```js
// Add element to the end of array
const arr1 = [1, 2, 3];
// push(element to add)
arr1.push(4); // [1, 2, 3, 4]

const arr2 = [1, 2, 3];
// concat(element to add)
arr2.concat([4, 5]); // [1, 2, 3, 4, 5]

// Add element to the beginning of array
const arr3 = [1, 2, 3];
// unshift(element to add)
arr3.unshift(0); // [0, 1, 2, 3]

// Add element to the beginning or end of array
const arr4 = [1, 2, 3];
// ... is the spread operator that spreads the array
arr4 = [...arr4, 4]; // [1, 2, 3, 4]

// Add element in the middle of array
const arr5 = [1, 2, 3];
// splice(start index, number of elements to remove, element to add)
arr5.splice(1, 0, 1.5); // [1, 1.5, 2, 3]
```

> [!INFO] JS Optimization for shift, unshift
>
> In JavaScript, when manipulating arrays through unshift and shift when the number of data items is less than 15,000, the engine optimizes this to have lower time complexity than other array manipulations.

> [!NOTE] Brackets in Official Documentation
>
> In official documentation, splice is shown as `array.splice(start[, deleteCount[, item1[, item2[, ...]]]])` like this. Parts wrapped in brackets are optional parameters, and parts not wrapped in brackets are required parameters. You can see that splice requires start. By the way, if you only provide start, it returns data after the start index and the original array only has data up to the start index.

## Data Deletion

```js
// To remove the last element of the array, use the pop method.
const arr1 = [1, 2, 3];
const result1 = arr1.pop(); // Remove and return the last element
console.log(arr1); // [1, 2]

// To remove the first element of the array, use the shift method.
// shift also optimizes up to 15,000 data items in the engine like unshift.
const arr2 = [1, 2, 3];
const result2 = arr2.shift(); // Remove and return the first element
console.log(arr2); // [2, 3]

// To remove an element at a specific position in the array, use the splice method.
const arr3 = [1, 2, 3];
const result3 = arr3.splice(1, 1); // Remove 1 element from index 1
console.log(arr3); // [1, 3]
```

## Applying Specific Operations (Using Higher-Order Functions)

JavaScript arrays have useful higher-order functions. They can replace complex logic using existing loops and conditionals.

```js
// Higher-order functions that apply specific operations to each element of the array
// map, filter, reduce

// Higher-order function that returns the result of applying specific operations to each element of the array
const arr1 = [1, 2, 3, 4];
// Returns a new array with each element of the array squared.
const squares = arr1.map((x) => x * x); // [1, 4, 9, 16]

// Higher-order function that returns an array composed only of elements that satisfy specific conditions
const arr2 = [1, 2, 3, 4];
// Returns an array composed only of even elements from the array.
const evens = arr2.filter((x) => x % 2 === 0); // [2, 4]

// Higher-order function that accumulates the result of applying specific operations to each element of the array
const arr3 = [1, 2, 3, 4];
// If you don't provide an initial value of 0, the first element of the array becomes the initial value.
const sum = arr3.reduce((x, y) => x + y, 0); // 10
```

# References

https://product.kyobobook.co.kr/detail/S000213641007

> [!SUMMARY]
>
> Algorithm concepts seem to disappear particularly quickly if you don't study them consistently.
> I'll study consistently so I can fill them back in when they disappear.
> If there are any incorrect knowledge, please leave a comment!
>
> Thank you for reading.

