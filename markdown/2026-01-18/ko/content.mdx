# useCallback, useMemo는 왜 쓸까

React에서 useCallback과 useMemo를 사용하는 이유는 단순히 "성능 최적화"가 아닙니다. JavaScript의 참조형 데이터 특성과 React의 의존성 배열 동작 방식을 이해하면, 이 훅들이 왜 필수적인 상황이 있는지 알 수 있습니다.

이 문서를 읽으면 다음을 이해할 수 있습니다:
- 원시형과 참조형의 메모리 동작 차이
- useEffect 의존성 배열에서 참조형이 위험한 이유
- ESLint가 경고하지 못하는 커스텀 훅 내부의 함정
- 참조형 데이터의 메모이제이션 설계 원칙

---

# 원시형과 참조형의 메모리 구조

JavaScript의 데이터 타입은 원시형(Primitive)과 참조형(Reference)으로 나뉩니다.

## 원시형 데이터

원시형은 값 자체가 변수에 저장됩니다.

```javascript
let a = 1;
let b = 1;

console.log(a === b); // true
```

`a`와 `b`는 각각 독립적인 메모리 공간에 `1`을 저장합니다. 비교 연산자(`===`)는 저장된 값 자체를 비교하므로 `true`를 반환합니다.

## 참조형 데이터

참조형은 메모리 주소가 변수에 저장됩니다.

```javascript
const obj1 = { value: 1 };
const obj2 = { value: 1 };

console.log(obj1 === obj2); // false
```

`obj1`과 `obj2`는 내용이 동일하지만 서로 다른 메모리 주소를 가리킵니다. 비교 연산자(`===`)는 주소를 비교하므로 `false`를 반환합니다.

```mermaid
flowchart LR
    subgraph 원시형
        A[변수 a] --> V1[값: 1]
        B[변수 b] --> V2[값: 1]
    end

    subgraph 참조형
        C[변수 obj1] --> M1[메모리 주소 @100]
        D[변수 obj2] --> M2[메모리 주소 @200]
        M1 --> O1["{ value: 1 }"]
        M2 --> O2["{ value: 1 }"]
    end
```

## 함수도 참조형입니다

함수는 JavaScript에서 일급 객체이며, 참조형 데이터입니다.

```javascript
const fn1 = () => console.log('hello');
const fn2 = () => console.log('hello');

console.log(fn1 === fn2); // false
```

동일한 코드를 가진 함수라도 선언할 때마다 새로운 메모리 주소가 할당됩니다.

## JavaScript 타입별 분류

```mermaid
flowchart TB
    subgraph 원시형["원시형 (Primitive)"]
        P1[number]
        P2[string]
        P3[boolean]
        P4[null]
        P5[undefined]
        P6[symbol]
        P7[bigint]
    end

    subgraph 참조형["참조형 (Reference)"]
        R1[Object]
        R2[Array]
        R3[Function]
        R4[Date]
        R5[Map / Set]
        R6[RegExp]
    end

    원시형 -->|"값 비교"| SAFE["deps에서 안전"]
    참조형 -->|"주소 비교"| DANGER["deps에서 주의 필요"]
```

---

# useEffect 의존성 배열과 참조형의 함정

React의 useEffect는 의존성 배열의 값이 변경될 때 콜백을 실행합니다. 문제는 이 비교가 `Object.is`로 수행된다는 점입니다.

## 원시형은 안전합니다

```jsx
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log('count 변경:', count);
  }, [count]);

  return <button onClick={() => setCount(count + 1)}>증가</button>;
}
```

`count`는 원시형(숫자)이므로 값이 실제로 변경될 때만 effect가 실행됩니다.

## 참조형은 위험합니다

```jsx
function UserProfile() {
  const [user, setUser] = useState({ name: 'Kim' });

  // 매 렌더링마다 새로운 객체 생성
  const config = { theme: 'dark' };

  useEffect(() => {
    console.log('config 변경됨');
  }, [config]); // 매 렌더링마다 실행됨

  return <div>{user.name}</div>;
}
```

`config`는 렌더링마다 새로운 메모리 주소를 가진 객체로 생성됩니다. 내용이 동일해도 React는 "변경됨"으로 판단합니다.

```mermaid
sequenceDiagram
    participant R as React
    participant C as Component
    participant E as useEffect

    R->>C: 첫 번째 렌더링
    C->>C: config = { theme: 'dark' } @100
    C->>E: deps 저장: [@100]
    E->>E: effect 실행

    R->>C: 두 번째 렌더링 (상태 변경)
    C->>C: config = { theme: 'dark' } @200
    C->>E: deps 비교: @100 !== @200
    E->>E: effect 또 실행 (불필요)
```

## 무한 리렌더링 발생 케이스

함수를 의존성 배열에 넣고, 그 함수 내부에서 상태를 변경하면 무한 루프가 발생합니다.

```jsx
function AutoSaveEditor() {
  const [content, setContent] = useState('');

  // 매 렌더링마다 새로운 함수 생성
  const saveDraft = () => {
    console.log('저장:', content);
    // 만약 여기서 상태를 변경한다면...
    setContent(content + ' (저장됨)');
  };

  useEffect(() => {
    saveDraft();
  }, [saveDraft]); // 무한 루프!

  return <textarea value={content} onChange={(e) => setContent(e.target.value)} />;
}
```

실행 흐름:
1. 컴포넌트 렌더링 → `saveDraft` 함수 생성 (@100)
2. useEffect 실행 → `saveDraft()` 호출 → `setContent` 실행
3. 상태 변경으로 리렌더링 → `saveDraft` 함수 재생성 (@200)
4. useEffect가 `@100 !== @200` 감지 → 다시 실행
5. 2~4 반복 (무한 루프)

```mermaid
flowchart TD
    A[컴포넌트 렌더링] --> B["saveDraft 함수 생성 (새 주소)"]
    B --> C["useEffect deps 비교"]
    C --> D{"주소가 다른가?"}
    D -->|Yes| E["effect 실행: saveDraft()"]
    E --> F["setContent 호출"]
    F --> G["상태 변경"]
    G --> A
    D -->|No| H["effect 건너뜀"]
```

### Chrome DevTools로 확인한 메모리 주소 변화

실제로 함수가 매 렌더링마다 새로운 메모리 주소를 갖는지 Chrome DevTools의 Memory 탭에서 확인할 수 있습니다.

아래 스크린샷은 Heap Snapshot을 비교한 결과입니다. `inlineSaveDraft` 함수가 각 스냅샷에서 다른 메모리 주소를 가지고 있음을 볼 수 있습니다.

**Snapshot 1에서의 함수 주소:**
![Snapshot 1](/images/2025-01-18/snapshot1.png)

**Snapshot 2에서 새로 생성된 함수들:**
![Snapshot 2](/images/2025-01-18/snapshot2.png)

**Snapshot 3에서 또 다른 주소의 함수:**
![Snapshot 3](/images/2025-01-18/snapshot3.png)

각 스냅샷에서 `inlineSaveDraft` 함수는 `@200175`, `@473745`, `@483163` 등 서로 다른 메모리 주소를 가집니다. 이것이 React가 매 렌더링마다 함수가 "변경됨"으로 판단하는 이유입니다.

## useCallback으로 해결하기

useCallback을 사용하면 함수의 참조를 안정적으로 유지할 수 있습니다.

```jsx
function AutoSaveEditor() {
  const [content, setContent] = useState('');

  // useCallback으로 함수 참조 안정화
  const saveDraft = useCallback(() => {
    console.log('저장:', content);
    // 상태 변경이 필요하면 함수형 업데이트 사용
  }, [content]); // content가 변경될 때만 함수 재생성

  useEffect(() => {
    saveDraft();
  }, [saveDraft]); // content가 변경될 때만 effect 실행

  return <textarea value={content} onChange={(e) => setContent(e.target.value)} />;
}
```

```mermaid
flowchart TD
    subgraph "useCallback 없음"
        A1[렌더링] --> B1["saveDraft @100"]
        A2[리렌더링] --> B2["saveDraft @200"]
        A3[리렌더링] --> B3["saveDraft @300"]
        B1 --> E1["effect 실행"]
        B2 --> E2["effect 실행"]
        B3 --> E3["effect 실행"]
    end

    subgraph "useCallback 적용"
        C1[렌더링] --> D1["saveDraft @100"]
        C2[리렌더링] --> D1
        C3[리렌더링] --> D1
        D1 --> F1["effect 1회만 실행"]
    end
```

## useMemo로 객체 안정화하기

객체나 배열이 deps에 들어가야 할 때는 useMemo를 사용합니다.

```jsx
function UserDashboard() {
  const [user, setUser] = useState({ name: 'Kim' });

  // useMemo로 객체 참조 안정화
  const config = useMemo(() => ({ theme: 'dark', locale: 'ko' }), []);

  useEffect(() => {
    applyConfig(config);
  }, [config]); // 최초 1회만 실행

  return <div>{user.name}</div>;
}
```

---

# React.memo와 메모이제이션

useCallback과 useMemo가 필요한 또 다른 중요한 케이스는 `React.memo`로 감싼 자식 컴포넌트에 props를 전달할 때입니다.

## React.memo의 동작 원리

`React.memo`는 props가 변경되지 않으면 리렌더링을 건너뜁니다. 하지만 props 비교도 `Object.is`로 수행됩니다.

```jsx
const ExpensiveChild = React.memo(({ onClick, data }) => {
  console.log('ExpensiveChild 렌더링');
  return <button onClick={onClick}>{data.label}</button>;
});

function Parent() {
  const [count, setCount] = useState(0);

  // 매 렌더링마다 새 함수/객체 생성
  const handleClick = () => console.log('clicked');
  const data = { label: 'Click me' };

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      {/* count가 변경될 때마다 ExpensiveChild도 리렌더링됨 */}
      <ExpensiveChild onClick={handleClick} data={data} />
    </>
  );
}
```

```mermaid
sequenceDiagram
    participant P as Parent
    participant M as React.memo
    participant C as ExpensiveChild

    P->>P: count 변경 → 리렌더링
    P->>P: handleClick = () => {} (새 주소)
    P->>P: data = { label } (새 주소)
    P->>M: props 전달
    M->>M: Object.is(oldProps.onClick, newProps.onClick)
    M->>M: false (주소가 다름)
    M->>C: 리렌더링 실행
    Note over C: memo 효과 없음!
```

## 메모이제이션으로 해결

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  // 참조 안정화
  const handleClick = useCallback(() => console.log('clicked'), []);
  const data = useMemo(() => ({ label: 'Click me' }), []);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      {/* count가 변경되어도 ExpensiveChild는 리렌더링되지 않음 */}
      <ExpensiveChild onClick={handleClick} data={data} />
    </>
  );
}
```

```mermaid
sequenceDiagram
    participant P as Parent
    participant M as React.memo
    participant C as ExpensiveChild

    P->>P: count 변경 → 리렌더링
    P->>P: handleClick (동일 주소 유지)
    P->>P: data (동일 주소 유지)
    P->>M: props 전달
    M->>M: Object.is(oldProps.onClick, newProps.onClick)
    M->>M: true (주소가 같음)
    Note over M: 리렌더링 건너뜀
    Note over C: 렌더링 안함!
```

---

# ESLint 경고의 한계와 커스텀 훅의 함정

## eslint-plugin-react-hooks의 역할

`eslint-plugin-react-hooks`는 메모이제이션되지 않은 함수를 의존성 배열에 넣으면 경고합니다.

```jsx
function Example() {
  const [count, setCount] = useState(0);

  // 메모이제이션되지 않은 함수
  const handleClick = () => {
    console.log(count);
  };

  useEffect(() => {
    handleClick();
  }, [handleClick]); // ESLint 경고: The 'handleClick' function makes the dependencies of useEffect Hook change on every render

  return <button onClick={handleClick}>{count}</button>;
}
```

이 경고는 "매 렌더링마다 함수가 재생성되어 effect가 불필요하게 실행될 수 있다"는 것을 알려줍니다. ESLint는 `useCallback`으로 감싸거나 effect 내부로 함수를 이동하라고 제안합니다.

## 커스텀 훅에서 반환된 함수는 경고하지 않습니다

문제는 커스텀 훅에서 반환된 메모이제이션되지 않은 함수를 deps에 넣으면 ESLint가 경고하지 않는다는 점입니다.

```jsx
// useAutoSave.ts - 메모이제이션 없이 함수 반환
function useAutoSave() {
  const [lastSaved, setLastSaved] = useState<Date | null>(null);

  // 메모이제이션되지 않은 함수 반환
  const save = (content: string) => {
    api.save(content);
    setLastSaved(new Date());
  };

  return { save, lastSaved };
}

// Component.tsx
function Editor() {
  const [content, setContent] = useState('');
  const { save } = useAutoSave(); // 매 렌더링마다 새로운 save 함수

  useEffect(() => {
    const timer = setInterval(() => save(content), 5000);
    return () => clearInterval(timer);
  }, [save, content]); // ESLint 경고 없음!

  return <textarea value={content} onChange={(e) => setContent(e.target.value)} />;
}
```

```mermaid
flowchart LR
    subgraph "useAutoSave Hook"
        A["save 함수 생성 (메모이제이션 없음)"]
        B["return { save }"]
    end

    subgraph Component
        C["const { save } = useAutoSave()"]
        D["useEffect deps: [save]"]
    end

    subgraph ESLint
        E["컴포넌트 내부 함수"]
        F["훅에서 반환된 함수"]
    end

    A --> B
    B --> C
    C --> D
    E -->|"경고함"| D
    F -->|"경고 안함"| D
```

ESLint는 컴포넌트 내부에서 선언한 함수가 deps에 들어가면 경고하지만, 훅에서 반환된 함수는 "이미 안정적인 참조일 것"이라고 가정합니다. 하지만 실제로는 훅 내부에서 메모이제이션하지 않으면 매 렌더링마다 새 함수가 생성됩니다.

## 결과: 숨겨진 성능 문제

```jsx
function Editor() {
  const [content, setContent] = useState('');
  const [cursor, setCursor] = useState(0);
  const { save } = useAutoSave(); // 메모이제이션 안된 함수

  useEffect(() => {
    const timer = setInterval(() => save(content), 5000);
    return () => clearInterval(timer);
  }, [save, content]); // ESLint 경고 없음, 하지만 문제 발생

  // cursor가 변경될 때마다 useAutoSave가 새 save 함수를 반환
  return (
    <textarea
      value={content}
      onChange={(e) => setContent(e.target.value)}
      onSelect={(e) => setCursor(e.target.selectionStart)}
    />
  );
}
```

커서 위치가 변경될 때마다:
1. 컴포넌트 리렌더링
2. `useAutoSave`가 새 `save` 함수 반환 (새 메모리 주소)
3. useEffect가 `save` 변경 감지 → effect 재실행
4. 기존 타이머 정리 후 새 타이머 생성

ESLint는 이 문제를 경고하지 않습니다. 훅에서 반환된 함수는 안정적인 참조라고 가정하기 때문입니다. 이것이 커스텀 훅 설계 시 반환값의 메모이제이션이 중요한 이유입니다.

---

# 메모이제이션 설계 원칙

커스텀 훅을 설계할 때는 반환값의 참조 안정성을 보장해야 합니다.

## 원칙 1: 참조형 반환값은 무조건 메모이제이션

훅에서 반환하는 함수나 객체는 의존성 배열에 들어갈 수 있습니다. 참조를 안정적으로 유지해야 합니다.

```jsx
// Bad: 매 렌더링마다 새 함수 생성
function useCounter() {
  const [count, setCount] = useState(0);

  const increment = () => setCount((c) => c + 1);
  const decrement = () => setCount((c) => c - 1);

  return { count, increment, decrement };
}

// Good: useCallback으로 함수 참조 안정화
function useCounter() {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => setCount((c) => c + 1), []);
  const decrement = useCallback(() => setCount((c) => c - 1), []);

  return { count, increment, decrement };
}
```

```mermaid
flowchart TB
    subgraph "메모이제이션 없음"
        A1[렌더링 1] --> B1["increment @100"]
        A2[렌더링 2] --> B2["increment @200"]
        A3[렌더링 3] --> B3["increment @300"]
    end

    subgraph "useCallback 적용"
        C1[렌더링 1] --> D1["increment @100"]
        C2[렌더링 2] --> D1
        C3[렌더링 3] --> D1
    end
```

## 원칙 2: 원시형 반환값은 계산 비용을 고려

원시형은 값 비교가 되므로 메모이제이션이 필수는 아닙니다. 계산 비용이 클 때만 useMemo를 사용합니다.

```jsx
// 메모이제이션 불필요: 단순 계산
function useItemCount(items) {
  const count = items.length; // O(1)
  return count;
}

// 메모이제이션 필요: 복잡한 계산
function useFilteredItems(items, filter) {
  const filtered = useMemo(
    () => items.filter((item) => item.category === filter), // O(n)
    [items, filter]
  );
  return filtered;
}
```

## 원칙 3: 객체 반환 시 useMemo로 감싸기

여러 값을 객체로 반환할 때는 useMemo로 객체 참조를 안정화합니다.

```jsx
// Bad: 매 렌더링마다 새 객체 생성
function useWindowSize() {
  const [size, setSize] = useState({ width: 0, height: 0 });

  useEffect(() => {
    const handler = () => setSize({ width: window.innerWidth, height: window.innerHeight });
    window.addEventListener('resize', handler);
    return () => window.removeEventListener('resize', handler);
  }, []);

  // 새 객체를 매번 생성
  return { width: size.width, height: size.height, isLarge: size.width > 1024 };
}

// Good: useMemo로 객체 안정화
function useWindowSize() {
  const [size, setSize] = useState({ width: 0, height: 0 });

  useEffect(() => {
    const handler = () => setSize({ width: window.innerWidth, height: window.innerHeight });
    window.addEventListener('resize', handler);
    return () => window.removeEventListener('resize', handler);
  }, []);

  return useMemo(
    () => ({ width: size.width, height: size.height, isLarge: size.width > 1024 }),
    [size.width, size.height]
  );
}
```

## 정리: 타입별 메모이제이션 가이드

| 반환값 타입        | 메모이제이션     | 이유                                     |
| ------------------ | ---------------- | ---------------------------------------- |
| 함수               | useCallback 필수 | 참조형, 의존성 배열에서 사용될 수 있음   |
| 객체/배열          | useMemo 필수     | 참조형, 의존성 배열에서 사용될 수 있음   |
| 숫자/문자열/불리언 | 계산 비용 고려   | 원시형은 값 비교, 비용이 클 때만 useMemo |

```mermaid
flowchart TD
    A["훅에서 값 반환"] --> B{"반환값 타입?"}
    B -->|"함수"| C["useCallback 필수"]
    B -->|"객체/배열"| D["useMemo 필수"]
    B -->|"원시형"| E{"계산 비용이 큰가?"}
    E -->|"Yes"| F["useMemo 권장"]
    E -->|"No"| G["메모이제이션 불필요"]
```

---

# 흔한 실수 패턴

## 실수 1: deps 배열 안에서 객체/배열 리터럴 사용

```jsx
// Bad: 매 렌더링마다 새 배열 생성
useEffect(() => {
  fetchUsers(userIds);
}, [[1, 2, 3]]); // 항상 새 배열!

// Good: useMemo 사용 또는 외부에서 상수로 정의
const userIds = useMemo(() => [1, 2, 3], []);
useEffect(() => {
  fetchUsers(userIds);
}, [userIds]);
```

## 실수 2: useCallback 내부에서 최신 state 참조

```jsx
// Bad: count가 변경되어도 오래된 값 참조
const handleClick = useCallback(() => {
  setCount(count + 1); // 클로저에 count가 고정됨
}, []); // deps가 비어있음

// Good: 함수형 업데이트 사용
const handleClick = useCallback(() => {
  setCount((prev) => prev + 1); // 항상 최신 값 사용
}, []);
```

## 실수 3: 불필요한 메모이제이션

```jsx
// Bad: 원시형은 메모이제이션 불필요
const doubled = useMemo(() => count * 2, [count]);

// Good: 그냥 계산
const doubled = count * 2;

// Good: 복잡한 계산만 메모이제이션
const sortedItems = useMemo(
  () => items.sort((a, b) => a.price - b.price),
  [items]
);
```

```mermaid
flowchart TD
    A["메모이제이션이 필요한가?"] --> B{"참조형인가?"}
    B -->|"Yes"| C{"deps에 들어가거나<br/>memo된 컴포넌트에 전달?"}
    C -->|"Yes"| D["메모이제이션 필요"]
    C -->|"No"| E["불필요할 수 있음"]
    B -->|"No (원시형)"| F{"계산 비용이 큰가?"}
    F -->|"Yes"| G["useMemo 고려"]
    F -->|"No"| H["메모이제이션 불필요"]
```

---

# 결론

useCallback과 useMemo는 단순한 성능 최적화 도구가 아닙니다.

```mermaid
flowchart TB
    subgraph 핵심["핵심 포인트"]
        A["참조형 = 매 렌더링마다 새 주소"]
        B["deps 비교 = Object.is (주소 비교)"]
        C["ESLint = 훅 반환값은 신뢰"]
    end

    subgraph 결과["발생하는 문제"]
        D["불필요한 effect 재실행"]
        E["무한 리렌더링"]
        F["React.memo 무효화"]
    end

    subgraph 해결["해결책"]
        G["useCallback - 함수 메모이제이션"]
        H["useMemo - 값/객체 메모이제이션"]
        I["커스텀 훅 설계 시 반환값 메모이제이션"]
    end

    A --> D
    A --> E
    A --> F
    B --> D
    B --> E
    C --> E

    D --> G
    D --> H
    E --> G
    E --> H
    F --> G
    F --> H
    F --> I
```

1. **참조형 데이터의 특성** 때문에 필요합니다. 내용이 같아도 매 렌더링마다 새로운 메모리 주소가 할당됩니다.
2. **useEffect 의존성 배열**에서 참조형을 그대로 사용하면 의도치 않은 effect 재실행이나 무한 루프가 발생합니다.
3. **React.memo로 감싼 컴포넌트**에 참조형 props를 전달하면 메모이제이션 효과가 사라집니다.
4. **ESLint는 커스텀 훅 경계를 넘어가면 경고하지 못합니다.** 훅 설계 시 반환값의 참조 안정성을 직접 보장해야 합니다.
5. **커스텀 훅에서는 참조형 반환값을 항상 메모이제이션**합니다. 원시형은 계산 비용을 고려해 결정합니다.
