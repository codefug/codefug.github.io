1:"$Sreact.fragment"
2:I[4480,["275","static/chunks/275-37076645b7fabe60.js","711","static/chunks/711-2e7798a9f451dfd2.js","702","static/chunks/702-06769fc6cb7dd61f.js","859","static/chunks/859-2e3810e8cb8b2a7a.js","845","static/chunks/845-2f7bc315f3802e5b.js","177","static/chunks/app/layout-397dcad387a70f0b.js"],"GoogleTagManager"]
3:I[3205,["275","static/chunks/275-37076645b7fabe60.js","711","static/chunks/711-2e7798a9f451dfd2.js","702","static/chunks/702-06769fc6cb7dd61f.js","859","static/chunks/859-2e3810e8cb8b2a7a.js","845","static/chunks/845-2f7bc315f3802e5b.js","177","static/chunks/app/layout-397dcad387a70f0b.js"],"default"]
4:I[7643,["275","static/chunks/275-37076645b7fabe60.js","711","static/chunks/711-2e7798a9f451dfd2.js","702","static/chunks/702-06769fc6cb7dd61f.js","859","static/chunks/859-2e3810e8cb8b2a7a.js","845","static/chunks/845-2f7bc315f3802e5b.js","177","static/chunks/app/layout-397dcad387a70f0b.js"],"SidebarProvider"]
5:I[379,["275","static/chunks/275-37076645b7fabe60.js","711","static/chunks/711-2e7798a9f451dfd2.js","702","static/chunks/702-06769fc6cb7dd61f.js","859","static/chunks/859-2e3810e8cb8b2a7a.js","845","static/chunks/845-2f7bc315f3802e5b.js","177","static/chunks/app/layout-397dcad387a70f0b.js"],"default"]
c:I[1484,["219","static/chunks/app/global-error-cab15e159dca7270.js"],"default"]
:HL["https://codefug.github.io/_next/static/media/518331124efecf5c-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["https://codefug.github.io/_next/static/css/560594e4c790f86c.css","style"]
:HL["https://codefug.github.io/_next/static/css/0944061766e538e2.css","style"]
:HL["https://codefug.github.io/_next/static/css/fc37ac2b1a278e8c.css","style"]
0:{"P":null,"b":"XT7kQrlLJedlNhUJWScUi","p":"https://codefug.github.io","c":["","posts","2025-06-21"],"i":false,"f":[[["",{"children":["posts",{"children":[["id","2025-06-21","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"https://codefug.github.io/_next/static/css/560594e4c790f86c.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"https://codefug.github.io/_next/static/css/0944061766e538e2.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"ko","suppressHydrationWarning":true,"children":[["$","$L2",null,{"gtmId":"$undefined"}],["$","body",null,{"className":"__className_75a1fa antialiased","children":["$","$L3",null,{"attribute":"class","defaultTheme":"system","enableSystem":true,"disableTransitionOnChange":true,"children":["$","$L4",null,{"defaultOpen":false,"children":[["$","$L5",null,{"totalFrontMatterList":[{"id":"2025-07-20","title":"집합","excerpt":"JS의 집합에 대해서 알아보자.","date":"2025-07-20","categories":["data-structure","javascript"],"header":{"teaser":"/images/2025-07-20/Pasted image 20250720151432.png"}},{"id":"2025-06-21","title":"트리","excerpt":"JS의 트리에 대해서 알아보자.","date":"2025-06-21","categories":["data-structure","javascript"],"header":{"teaser":"/images/2025-06-21/Pasted image 20250621101921.png"}},{"id":"2025-06-14","title":"해시","excerpt":"JS의 해시에 대해서 알아보자.","date":"2025-06-14","categories":["data-structure","javascript"],"header":{"teaser":"/images/2025-06-14/Pasted image 20250617224108.png"}},{"id":"2025-06-07","title":"큐","excerpt":"JS의 큐에 대해서 알아보자.","date":"2025-06-07","categories":["data-structure","javascript"],"header":{"teaser":"/images/2025-06-07/Pasted image 20250617212028.png"}},{"id":"2025-05-31","title":"스택","excerpt":"JS의 스택에 대해서 알아보자.","date":"2025-05-31","categories":["data-structure","javascript"],"header":{"teaser":"/images/2025-05-31/Pasted image 20250617080823.png"}},{"id":"2025-05-24","title":"배열","excerpt":"JS의 배열에 대해서 알아보자.","date":"2025-05-24","categories":["data-structure","javascript"],"header":{"teaser":"/images/2025-05-24/Pasted image 20250615181200.png"}},{"id":"2024-11-10","title":"Asynchronous JavaScript","excerpt":"microtask queue, macrotask queue, call stack, web api와 관련된 비동기 동작 방식, 비동기 관련 역사와 비동기 코드의 다양한 활용법들을 알아보자.","date":"2024-11-10","categories":["javascript"],"header":{"teaser":"/images/logos/JS.svg"}},{"id":"2024-09-14-4","title":"(꼼꼼 프로젝트) streaming 방식의 tanstack query","excerpt":"infinite scroll, optimistic update 그리고 streaming 방식이 결합된 쿼리 처리 ( useSuspenseQuery, useSuspenseInfiniteQuery )","date":"2024-09-14","categories":["kkom-kkom"],"header":{"teaser":"/images/logos/tanstackQuery.png"}},{"id":"2024-09-14-3","title":"(꼼꼼 프로젝트) 클라이언트와 서버 둘다 호환되는 fetch 구현","excerpt":"서버 액션을 활용한 refresh token rotation, 커링 함수를 이용한 리팩토링","date":"2024-09-14","categories":["kkom-kkom"],"header":{"teaser":"/images/logos/fetch.png"}},{"id":"2024-09-14-2","title":"(꼼꼼 프로젝트) startTransition, progress bar 구현에 대한 고민","excerpt":"progress bar 로직 연구하기(startTransition), next-nprogress-bar","date":"2024-09-14","categories":["kkom-kkom"],"header":{"teaser":"/images/logos/nprogress.png"}},{"id":"2024-09-14-1","title":"(꼼꼼 프로젝트) toss slash 분석, zustand와 연결된 커스텀 overlay 훅 구현","excerpt":"stacking context, compound pattern, 전역 상태를 활용한다는 것의 의미, 토스 개발자 실력 흡수하기","date":"2024-09-14","categories":["kkom-kkom"],"header":{"teaser":"/images/logos/toss.png"}},{"id":"2024-09-11","title":"(꼼꼼 프로젝트) 공통 버튼 컴포넌트의 종류를 쉽게 관리하고 누구나 쉽게 확인할 수 있게 하는 방법","excerpt":"tailwind로 조건부 처리를 간편하게 하는 방법, 비개발자도 스타일을 쉽게 확인할 수 있도록 storybook 연동","date":"2024-09-11","categories":["kkom-kkom"],"header":{"teaser":"/images/logos/storybook.png"}},{"id":"2024-07-22-2","title":"(급페이 프로젝트) 개발환경에만 집중하기 위한 여정","excerpt":"접근 제한을 위한 미들웨어 처리, vercel CLI을 이용한 organization 무료 자동 배포, 프리뷰","date":"2024-07-22","categories":["gheuppay"],"header":{"teaser":"/images/logos/vercel.png"}},{"id":"2024-07-22-1","title":"(급페이 프로젝트) 알림창 무한 스크롤을 위한 여정 (mock fetching을 위한 MSW 도입기)","excerpt":"msw를 활용해서 프론트엔드 개발이 다 되어있지 않은 상태에서도 무한 스크롤 구현을 확인할 수 있게 되었습니다.","date":"2024-07-22","categories":["gheuppay"],"header":{"teaser":"/images/logos/msw.png"}},{"id":"2024-07-21","title":"(급페이 프로젝트) 카드 렌더링을 최적화하여 UX를 향상시키기 위한 머나먼 여정","excerpt":"server component 설계를 이용한 suspense 적극 활용, 이를 위해서 next cookie를 사용하면서 겪은 문제들을 적은 글입니다.","date":"2024-07-21","categories":["gheuppay"],"header":{"teaser":"/images/logos/next-cookie.png"}},{"id":"2024-06-18","title":"React Testing","excerpt":"React Testing Library, Vitest, Jest","date":"2024-06-18","categories":["reactdeepdive"],"header":{"teaser":"/images/logos/reactdeepdive.jpg"}},{"id":"2024-06-17","title":"로그인 구현 (zustand, zod + react-hook-form, RTR)","excerpt":"zustand를 이용한 로그인 상태 전역 관리, zod를 이용한 간단한 스키마 전개, react-hook-form을 이용한 간단한 validation, axios를 이용한 간단한 api 요청 처리","date":"2024-06-17","categories":["react"],"header":{"teaser":"/images/logos/zod.png"}},{"id":"2024-06-15","title":"Dev tool","excerpt":"리액트 과거, 현재, 미래","date":"2024-06-15","categories":["web"],"header":{"teaser":"/images/logos/reactdeepdive.jpg"}},{"id":"2024-06-14","title":"마이그레이션 중 발생한 Vite 환경 변수 처리","excerpt":"Vite_ENV","date":"2024-06-14","categories":["react"],"header":{"teaser":"/images/logos/react.png"}},{"id":"2024-06-10","title":"React Debugging","excerpt":"react-dev-tools 정리, 실습","date":"2024-06-10","categories":["react"],"header":{"teaser":"/images/logos/react.png"}},{"id":"2024-06-08","title":"자잘한 Next.js 트러블 슈팅들","excerpt":"react-responsive를 사용하지 못하는 상황, dotenv 사용시 문제 발생","date":"2024-06-08","categories":["nextjs"],"header":{"teaser":"/images/logos/Nextjs.png"}},{"id":"2024-05-31","title":"Next는 왜 쓸까","excerpt":"CSR SSG SSR","date":"2024-05-31","categories":["nextjs"],"header":{"teaser":"/images/logos/Nextjs.png"}},{"id":"2024-05-23","title":"리액트는 왜 쓸까","excerpt":"리액트 과거, 현재, 미래","date":"2024-05-23","categories":["react"],"header":{"teaser":"/images/logos/reactdeepdive.jpg"}},{"id":"2024-05-22","title":"TS는 왜 쓸까 (위대한 TS)","excerpt":"JS를 완벽하게 하기 위한 여정","date":"2024-05-22","categories":["typescript"],"header":{"teaser":"/images/logos/TS.png"}},{"id":"2024-05-20","title":"Fandom-k 프로젝트 회고3","excerpt":"Github Actions, 최종 결과","date":"2024-05-20","categories":["fandomk"],"header":{"teaser":"/images/logos/githubActions.png"}},{"id":"2024-05-19","title":"Fandom-k 프로젝트 회고2","excerpt":"fetch, scroll to Top, infinite scroll 라이브러리 제거","date":"2024-05-19","categories":["fandomk"],"header":{"teaser":"/images/logos/fetch.png"}},{"id":"2024-05-18","title":"Fandom-k 프로젝트 회고1","excerpt":"팀 프로젝트 세팅, infinite scroll, skeleton","date":"2024-05-18","categories":["fandomk"],"header":{"teaser":"/images/logos/infinite-scroll.png"}}]}],"$L6"]}]}]}]]}]]}],{"children":["posts","$L7",{"children":[["id","2025-06-21","d"],"$L8",{"children":["__PAGE__","$L9",{},null,false]},null,false]},null,false]},["$La",[],[]],false],"$Lb",false]],"m":"$undefined","G":["$c",[]],"s":false,"S":true}
d:I[995,["275","static/chunks/275-37076645b7fabe60.js","711","static/chunks/711-2e7798a9f451dfd2.js","702","static/chunks/702-06769fc6cb7dd61f.js","859","static/chunks/859-2e3810e8cb8b2a7a.js","845","static/chunks/845-2f7bc315f3802e5b.js","177","static/chunks/app/layout-397dcad387a70f0b.js"],"default"]
e:I[1423,[],""]
f:I[9235,[],""]
10:I[1702,["702","static/chunks/702-06769fc6cb7dd61f.js","345","static/chunks/app/not-found-f1d1741ea9f777fb.js"],""]
11:I[3732,["507","static/chunks/app/posts/%5Bid%5D/layout-00a6dbf17396ee76.js"],"default"]
13:I[8445,[],"OutletBoundary"]
15:I[7867,[],"AsyncMetadataOutlet"]
17:I[3275,["275","static/chunks/275-37076645b7fabe60.js","711","static/chunks/711-2e7798a9f451dfd2.js","702","static/chunks/702-06769fc6cb7dd61f.js","880","static/chunks/app/posts/%5Bid%5D/page-29bdb118dd6abf99.js"],"Image"]
18:I[8445,[],"ViewportBoundary"]
1a:I[8445,[],"MetadataBoundary"]
1b:"$Sreact.suspense"
6:["$","$Ld",null,{"children":["$","$Le",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$Lf",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","div",null,{"children":[["$","h2",null,{"children":"Not Found"}],["$","p",null,{"children":"잘못된 페이지에요!"}],["$","$L10",null,{"href":"/","children":"홈으로 돌아가기"}]]}],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]
7:["$","$1","c",{"children":[null,["$","$Le",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$Lf",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}]
8:["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"https://codefug.github.io/_next/static/css/fc37ac2b1a278e8c.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","div",null,{"className":"prose mx-auto mb-10 overflow-auto dark:prose-invert","children":[["$","$Le",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$Lf",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}],["$","$L11",null,{}]]}]]}]
9:["$","$1","c",{"children":["$L12",null,["$","$L13",null,{"children":["$L14",["$","$L15",null,{"promise":"$@16"}]]}]]}]
a:["$","div","l",{"className":"flex h-full items-center justify-center","children":["$","div",null,{"className":"flex flex-col items-center","children":[["$","div",null,{"className":"scale-[1.15] animate-pulse transition-transform","children":["$","$L17",null,{"src":"/images/main-logo.png","alt":"로딩 중...","width":120,"height":120,"className":"drop-shadow-lg"}]}],["$","p",null,{"className":"mt-6 animate-pulse text-lg font-bold text-gray-600","children":"Codefug Blog"}]]}]}]
b:["$","$1","h",{"children":[null,[["$","$L18",null,{"children":"$L19"}],["$","meta",null,{"name":"next-size-adjust","content":""}]],["$","$L1a",null,{"children":["$","div",null,{"hidden":true,"children":["$","$1b",null,{"fallback":null,"children":"$L1c"}]}]}]]}]
19:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
14:null
1d:I[9283,[],"IconMark"]
16:{"metadata":[["$","title","0",{"children":"Codefug Blog"}],["$","meta","1",{"name":"description","content":"프로젝트 경험과 개발 노트를 공유하는 블로그"}],["$","meta","2",{"name":"author","content":"Codefug"}],["$","meta","3",{"name":"keywords","content":"개발,프로그래밍,React,Next.js,JavaScript,TypeScript,블로그"}],["$","meta","4",{"name":"creator","content":"Codefug"}],["$","meta","5",{"name":"publisher","content":"Codefug"}],["$","meta","6",{"property":"og:title","content":"Codefug Blog"}],["$","meta","7",{"property":"og:description","content":"project experiences and development notes"}],["$","meta","8",{"property":"og:url","content":"https://codefug-blog.vercel.app"}],["$","meta","9",{"property":"og:image","content":"https://codefug.github.io/images/main-logo.png"}],["$","meta","10",{"property":"og:image:alt","content":"Codefug Blog"}],["$","meta","11",{"property":"og:type","content":"website"}],["$","meta","12",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","13",{"name":"twitter:title","content":"Codefug Blog"}],["$","meta","14",{"name":"twitter:description","content":"project experiences and development notes"}],["$","meta","15",{"name":"twitter:image","content":"https://codefug.github.io/images/main-logo.png"}],["$","meta","16",{"name":"twitter:image:alt","content":"Codefug Blog"}],["$","link","17",{"rel":"icon","href":"/icon.ico?f00882ffa3186f37","type":"image/x-icon","sizes":"16x16"}],["$","$L1d","18",{}]],"error":null,"digest":"$undefined"}
1c:"$16:metadata"
1e:I[3499,["275","static/chunks/275-37076645b7fabe60.js","711","static/chunks/711-2e7798a9f451dfd2.js","702","static/chunks/702-06769fc6cb7dd61f.js","880","static/chunks/app/posts/%5Bid%5D/page-29bdb118dd6abf99.js"],"GtmPageView"]
1f:I[5276,["275","static/chunks/275-37076645b7fabe60.js","711","static/chunks/711-2e7798a9f451dfd2.js","702","static/chunks/702-06769fc6cb7dd61f.js","880","static/chunks/app/posts/%5Bid%5D/page-29bdb118dd6abf99.js"],"default"]
12:["$","section",null,{"children":[["$","$L1e",null,{"slug":"2025-06-21"}],["$","header",null,{"className":"mb-8","children":[["$","div",null,{"className":"relative mb-6 h-[300px] w-full overflow-hidden rounded-xl sm:h-[400px] md:h-[450px]","children":[["$","$L17",null,{"src":"/images/2025-06-21/Pasted image 20250621101921.png","alt":"트리","fill":true,"sizes":"(max-width: 768px) 100vw, 1200px","priority":true,"className":"object-cover object-center transition-transform duration-500 hover:scale-105"}],["$","div",null,{"className":"absolute inset-0 bg-gradient-to-b from-transparent to-black/70"}],["$","div",null,{"className":"absolute left-4 top-4 flex flex-wrap gap-2 sm:left-6 sm:top-6","children":[["$","div","data-structure",{"className":"inline-flex items-center rounded-md border px-2.5 py-0.5 transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 border-transparent bg-white/90 text-xs font-medium text-gray-800 hover:bg-white sm:text-sm","children":[["$","svg",null,{"ref":"$undefined","xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-tag mr-1 h-3 w-3","children":[["$","path","vktsd0",{"d":"M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z"}],["$","circle","kqv944",{"cx":"7.5","cy":"7.5","r":".5","fill":"currentColor"}],"$undefined"]}]," ","data-structure"]}],["$","div","javascript",{"className":"inline-flex items-center rounded-md border px-2.5 py-0.5 transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 border-transparent bg-white/90 text-xs font-medium text-gray-800 hover:bg-white sm:text-sm","children":[["$","svg",null,{"ref":"$undefined","xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-tag mr-1 h-3 w-3","children":[["$","path","vktsd0",{"d":"M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z"}],["$","circle","kqv944",{"cx":"7.5","cy":"7.5","r":".5","fill":"currentColor"}],"$undefined"]}]," ","javascript"]}]]}]]}],["$","div",null,{"className":"mb-6 space-y-4","children":[["$","h1",null,{"className":"mb-0 text-3xl font-bold tracking-tight text-gray-900 dark:text-gray-50 sm:text-4xl md:text-5xl","children":"트리"}],["$","div",null,{"className":"flex items-center justify-end gap-4 text-sm text-gray-600 dark:text-gray-400","children":["$","div",null,{"className":"flex items-center","children":[["$","svg",null,{"ref":"$undefined","xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-calendar-days mr-2 h-4 w-4","children":[["$","path","1cmpym",{"d":"M8 2v4"}],["$","path","4m81vk",{"d":"M16 2v4"}],["$","rect","1hopcy",{"width":"18","height":"18","x":"3","y":"4","rx":"2"}],["$","path","8toen8",{"d":"M3 10h18"}],["$","path","6423bh",{"d":"M8 14h.01"}],["$","path","1etili",{"d":"M12 14h.01"}],["$","path","1gbofw",{"d":"M16 14h.01"}],["$","path","lrp35t",{"d":"M8 18h.01"}],["$","path","mhygvu",{"d":"M12 18h.01"}],["$","path","kzsmim",{"d":"M16 18h.01"}],"$undefined"]}],["$","time",null,{"dateTime":"2025-06-21","children":"2025-06-21"}]]}]}],["$","p",null,{"className":"text-lg leading-relaxed text-gray-600 dark:text-gray-300 md:text-xl","children":"JS의 트리에 대해서 알아보자."}]]}],["$","div",null,{"className":"border-b border-gray-200 dark:border-gray-800"}]]}],["$","section",null,{"className":"lg:flex lg:items-baseline","children":[["$","$L1f",null,{}],["$","section",null,{"className":"max-w-full","children":[["$","p",null,{"children":"트리는 데이터를 저장하고 탐색하기에 유용한 구조를 갖고 있습니다. 계층 구조로 표현하고자 할 때 많이 사용되는데요. 같이 알아봅시다."}],"\n",["$","blockquote",null,{"className":"bg-quote-blue border-blue-500 rounded-xl border-y border-r border-y-gray-400 border-r-gray-400 border-opacity-30 p-4 not-italic","children":["$L20","$L21"]}],"\n","$L22","\n","$L23","\n","$L24","\n","$L25","\n","$L26","\n","$L27","\n","$L28","\n","$L29","\n","$L2a","\n","$L2b","\n","$L2c","\n","$L2d","\n","$L2e","\n","$L2f","\n","$L30","\n","$L31","\n","$L32","\n","$L33","\n","$L34","\n","$L35","\n","$L36","\n","$L37","\n","$L38","\n","$L39","\n","$L3a","\n","$L3b","\n","$L3c","\n","$L3d","\n","$L3e","\n","$L3f","\n","$L40","\n","$L41","\n","$L42","\n","$L43","\n","$L44","\n","$L45","\n","$L46","\n","$L47","\n","$L48","\n","$L49","\n","$L4a","\n","$L4b","\n","$L4c","\n","$L4d","\n","$L4e","\n","$L4f","\n","$L50","\n","$L51","\n","$L52","\n","$L53","\n","$L54","\n","$L55","\n","$L56","\n","$L57","\n","$L58","\n","$L59","\n","$L5a","\n","$L5b","\n","$L5c","\n","$L5d","\n","$L5e","\n","$L5f","\n","$L60","\n","$L61","\n","$L62","\n","$L63","\n","$L64","\n","$L65","\n","$L66","\n","$L67","\n","$L68","\n","$L69","\n","$L6a","\n","$L6b","\n","$L6c","\n","$L6d","\n","$L6e","\n","$L6f","\n","$L70","\n","$L71","\n","$L72","\n","$L73","\n","$L74","\n","$L75","\n","$L76","\n","$L77","\n","$L78","\n","$L79","\n","$L7a","\n","$L7b","\n","$L7c","\n","$L7d","\n","$L7e","\n","$L7f","\n","$L80","\n","$L81","\n","$L82","\n","$L83","\n","$L84","\n","$L85","\n","$L86","\n","$L87","\n","$L88"]}]]}]]}]
20:["$","div",null,{"className":"text-blue-500 flex items-center gap-1 text-lg font-bold md:text-2xl","children":[["$","svg",null,{"ref":"$undefined","xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-pencil","children":[["$","path","1a8usu",{"d":"M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z"}],["$","path","1mk7zo",{"d":"m15 5 4 4"}],"$undefined"]}],["$","div",null,{"children":"트리가 활용되는 분야"}]]}]
21:["$","section",null,{"className":"text-sm font-semibold text-black md:text-base","children":["\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"인공지능: 인공지능의 판단 기준을 만들 때 의사 결정 트리를 사용합니다."}],"\n",["$","li",null,{"children":"자동 완성 기능: 문자열 처리에도 트리가 많이 활용됩니다. 검색 엔진에서도 자동 검색어 추천 기능도 trie라는 트리 구조를 활용합니다."}],"\n",["$","li",null,{"children":"데이터베이스: 데이터를 쉽게 검색, 삽입, 삭제할 수 있도록 트리를 활용해서 데이터를 구조화하고 인덱싱합니다. 이때 B-트리나 B+트리를 많이 사용해요."}],"\n"]}],"\n"]}]
22:["$","h1",null,{"id":0,"className":"hltr-red","children":"개념"}]
23:["$","p",null,{"children":"트리는 나무 기둥에서 가지가 뻗어나가는 모습을 거꾸로 뒤집어 놓은 모양의 데이터 구조에요."}]
24:["$","p",null,{"children":[["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250621101921.png","alt":""}],"\n다양한 용어들이 존재하는데요. 하나씩 알아봅시다."]}]
25:["$","h2",null,{"id":1,"className":"hltr-orange","children":"구성"}]
26:["$","h3",null,{"id":2,"className":"hltr-yellow","children":"트리를 구성하는 노드"}]
27:["$","p",null,{"children":"노드는 트리를 구성하는 요소이며 가장 위에 있는 노드를 루트 노드라고 해요. 위 그림에서는 1을 값으로 갖고 있는 노드가 루트 노드입니다."}]
28:["$","h4",null,{"id":3,"className":"hltr-green","children":"부모-자식, 형제 관계를 가지는 노드"}]
29:["$","p",null,{"children":"가족 관련된 용어들이 사용되는 경우가 있습니다."}]
2a:["$","ul",null,{"children":["\n",["$","li",null,{"children":["같은 부모 노드를 갖는 노드: ",["$","strong",null,{"children":"형제 노드"}]]}],"\n",["$","li",null,{"children":["트리에서 특정 노드 아래에 있는 노드가 있다면 특정 노드는 ",["$","strong",null,{"children":"부모 노드"}],", 아래 있는 노드는 ",["$","strong",null,{"children":"자식 노드"}]," 라고 해요."]}],"\n"]}]
2b:["$","h4",null,{"id":4,"className":"hltr-green","children":"자식이 없는 말단 노드"}]
2c:["$","p",null,{"children":["자식이 없는 노드는 ",["$","strong",null,{"children":"리프 노드"}],"라고 해요."]}]
2d:["$","h3",null,{"id":5,"className":"hltr-yellow","children":"노드를 연결하는 에지"}]
2e:["$","p",null,{"children":["노드와 노드를 이어주는 선을 ",["$","strong",null,{"children":"edge"}]," 또는 ",["$","strong",null,{"children":"간선"}]," 이라고 합니다."]}]
2f:["$","p",null,{"children":"트리는 노드와 노드가 단방향 간선으로 연결되어 있고 루트 노드에서 각 노드까지 경로는 유일해요."}]
30:["$","p",null,{"children":["루트 노드로부터 특정 노드까지 거쳐가는 최소한의 간선 수를 ",["$","strong",null,{"children":"레벨"}],"로 표현합니다. ( 루트는 0 그 이후부터 1 2 3 4 ... )"]}]
31:["$","h4",null,{"id":6,"className":"hltr-green","children":"아래로 향하는 간선의 개수, 차수"}]
32:["$","p",null,{"children":["특정 노드에서 아래로 향하는 간선의 개수를 ",["$","strong",null,{"children":"차수"}],"라고 해요. 노드 1은 차수가 3이라고 할 수 있습니다."]}]
33:["$","h1",null,{"id":7,"className":"hltr-red","children":"이진 트리 구현"}]
34:["$","p",null,{"children":["모든 노드의 최대 차수가 2를 넘지 않는 트리를 ",["$","strong",null,{"children":"이진 트리"}]," 라고 합니다.\n",["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250621105144.png","alt":""}],"\n구현할 수 있는 방법에는 두 가지가 있어요."]}]
35:["$","ul",null,{"children":["\n",["$","li",null,{"children":"배열을 사용하는 방법"}],"\n",["$","li",null,{"children":"포인터를 사용하는 방법"}],"\n"]}]
36:["$","p",null,{"children":"이진 트리를 구현해보면서 트리랑 좀 더 친해져봅시다."}]
37:["$","h2",null,{"id":8,"className":"hltr-orange","children":"배열로 구현하기"}]
38:["$","p",null,{"children":"배열은 선형 자료구조이고 트리는 계층 자료구조입니다. 배열로 트리를 표현하려면 다음 3가지 규칙이 필요해요."}]
39:["$","ol",null,{"children":["\n",["$","li",null,{"children":[["$","strong",null,{"children":"루트 노드"}],"는 배열 인덱스 ",["$","strong",null,{"children":"1번에 저장"}],"합니다."]}],"\n",["$","li",null,{"children":[["$","strong",null,{"children":"왼쪽"}]," 자식 노드의 배열 인덱스는 ",["$","strong",null,{"children":"부모 노드의 배열 인덱스 x 2"}],"입니다."]}],"\n",["$","li",null,{"children":[["$","strong",null,{"children":"오른쪽"}]," 자식 노드의 배열 인덱스는 ",["$","strong",null,{"children":"부모 노드의 배열 인덱스 x 2 + 1"}],"입니다."]}],"\n"]}]
3a:["$","p",null,{"children":["위 규칙에 맞게 구현하면 다음과 같아요.\n",["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250621105442.png","alt":""}]]}]
3b:["$","p",null,{"children":["인덱스만 살펴보면 1 2 4 8 이렇게 인덱스가 ",["$","code",null,{"children":"부모 * 2"}],"로 증가합니다. 점선 화살표를 따라가며 인덱스를 확인해보면 1 3 7로 흘러가는 것을 보실 수 있는데요. ",["$","code",null,{"children":"부모 * 2 + 1"}],"로 증가하는 것을 보실 수 있습니다."]}]
3c:["$","p",null,{"children":["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250621105813.png","alt":""}]}]
3d:["$","p",null,{"children":["루트 노드를 0으로 설정하면 왼쪽 자식 노드는 ",["$","code",null,{"children":"부모 * 2 + 1"}]," 이고 오른쪽 자식 노드는 ",["$","code",null,{"children":"부모 * 2 + 2"}],"가 됩니다."]}]
3e:["$","p",null,{"children":"배열로 구현하면 되는 것 아닌가 싶으실 수 있는데요. 배열로 구현하면 위 그림에서 14 인덱스를 위해 9 10 11 12 13 인덱스가 비어 있는 것처럼 빈 인덱스가 생기는 상황이 올 수 밖에 없습니다."}]
3f:["$","blockquote",null,{"children":["\n",["$","p",null,{"children":"이진 트리의 노드가 N개일 때, 배열로 이진 트리를 생성하면 O(N)이 걸립니다."}],"\n"]}]
40:["$","h2",null,{"id":9,"className":"hltr-orange","children":"포인터로 구현하기"}]
41:["$","p",null,{"children":"포인터로 구현된 트리에서 노드는 노드의 값, 왼쪽 자식 노드, 오른쪽 자식 노드를 가집니다."}]
42:["$","p",null,{"children":["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250621111301.png","alt":""}]}]
43:["$","p",null,{"children":["포인터로 구현된 트리는 배열과 달리 인덱스 연산을 하지 않으므로 메모리 공간을 낭비하지 않아요.\n",["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250621111338.png","alt":""}]]}]
44:["$","p",null,{"children":"아래 클래스를 통해서 한 노드를 구현하고 left, right 프로퍼티로 연결하는 방식으로 구현해요!"}]
45:["$","pre",null,{"children":["$","code",null,{"className":"hljs language-ts","children":[["$","span",null,{"className":"hljs-keyword","children":"class"}]," ",["$","span",null,{"className":"hljs-title class_","children":"Node"}],"(){\n  ",["$","span",null,{"className":"hljs-title function_","children":"constructor"}],"(",["$","span",null,{"className":"hljs-params","children":"value"}],"){\n    ",["$","span",null,{"className":"hljs-variable language_","children":"this"}],".",["$","span",null,{"className":"hljs-property","children":"value"}]," = value;\n    ",["$","span",null,{"className":"hljs-variable language_","children":"this"}],".",["$","span",null,{"className":"hljs-property","children":"left"}]," = ",["$","span",null,{"className":"hljs-literal","children":"null"}],";\n    ",["$","span",null,{"className":"hljs-variable language_","children":"this"}],".",["$","span",null,{"className":"hljs-property","children":"right"}]," = ",["$","span",null,{"className":"hljs-literal","children":"null"}],";\n  }\n}\n"]}]}]
46:["$","h1",null,{"id":10,"className":"hltr-red","children":"이진 트리 순회하기"}]
47:["$","p",null,{"children":["데이터를 위해 특정 자료구조를 빠짐 없이 방문하는 것을 ",["$","strong",null,{"children":"순회"}],"라고 하는데요. 배열로 치면 배열의 인덱스로 특정 데이터를 검색할 때 순회가 필요하죠. 트리에서의 순회에는 총 3가지 방법이 있습니다"]}]
48:["$","p",null,{"children":"간단하게 설명해보면 다음과 같아요."}]
49:["$","ul",null,{"children":["\n",["$","li",null,{"children":"전위 순회 ( Preorder ) : 값 > 왼쪽 자식 > 오른쪽 자식 순서로 방문"}],"\n",["$","li",null,{"children":"중위 순회 ( Inorder ) : 왼쪽 자식 > 값 > 오른쪽 자식 순서로 방문"}],"\n",["$","li",null,{"children":"후위 순회 ( Postorder ) : 왼쪽 자식 > 오른쪽 자식 > 값 순서로 방문\n더 자세히 알아봅시다."}],"\n"]}]
4a:["$","h2",null,{"id":11,"className":"hltr-orange","children":"전위 순회"}]
4b:["$","p",null,{"children":"현재 노드 > 왼쪽 자식 노드 > 오른쪽 자식 노드 순서로 방문합니다."}]
4c:["$","blockquote",null,{"className":"bg-quote-blue border-blue-500 rounded-xl border-y border-r border-y-gray-400 border-r-gray-400 border-opacity-30 p-4 not-italic","children":[["$","div",null,{"className":"text-blue-500 flex items-center gap-1 text-lg font-bold md:text-2xl","children":["$20:props:children:0",["$","div",null,{"children":"방문"}]]}],["$","section",null,{"className":"text-sm font-semibold text-black md:text-base","children":["\n",["$","p",null,{"children":"탐색에서 방문이란 탐색을 마친 상태를 말합니다. 탐색 과정에서 지나치 는 것과 그렇지 않은 것을 구분하기 위해 방문이라는 용어를 사용합니다. 다음 그림을 보면 한 집은 집 앞을 지나가기만 했고, 나머지 두 집은 방문을 완료했습니다."}],"\n",["$","p",null,{"children":["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250622145855.png","alt":""}]}],"\n"]}]]}]
4d:["$","p",null,{"children":"아래 배열을 전위 순회한다고 해봅시다."}]
4e:["$","pre",null,{"children":["$","code",null,{"className":"hljs language-ts","children":[["$","span",null,{"className":"hljs-keyword","children":"const"}]," a = [",["$","span",null,{"className":"hljs-literal","children":"null"}],", ",["$","span",null,{"className":"hljs-number","children":"1"}],", ",["$","span",null,{"className":"hljs-number","children":"4"}],", ",["$","span",null,{"className":"hljs-number","children":"8"}],", ",["$","span",null,{"className":"hljs-number","children":"3"}],", ",["$","span",null,{"className":"hljs-number","children":"5"}],", ",["$","span",null,{"className":"hljs-literal","children":"null"}],", ",["$","span",null,{"className":"hljs-number","children":"7"}],", ",["$","span",null,{"className":"hljs-number","children":"2"}],", ",["$","span",null,{"className":"hljs-literal","children":"null"}],", ",["$","span",null,{"className":"hljs-literal","children":"null"}],", ",["$","span",null,{"className":"hljs-literal","children":"null"}],", ",["$","span",null,{"className":"hljs-number","children":"6"}],", ",["$","span",null,{"className":"hljs-literal","children":"null"}],"];\n"]}]}]
4f:["$","p",null,{"children":["인덱스 1부터 루트라고 가정한 트리이므로 그림으로 그리면 다음과 같은데요.\n",["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250622145125.png","alt":""}]]}]
50:["$","p",null,{"children":"루트 부터 순회를 시작해보자구요. 우선 현재 노드 > 왼쪽 자식 > 오른쪽 자식이기에 루트를 찍고 시작합니다."}]
51:["$","p",null,{"children":[["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250622144957.png","alt":""}],"\n반환값: 1"]}]
52:["$","p",null,{"children":["이후 왼쪽 자식 노드로 가서 다시 순회를 돌립니다. 이제 4가 현재 노드가 되었어요.\n",["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250622145209.png","alt":""}],"\n반환값: 1, 4"]}]
53:["$","p",null,{"children":["이 방식으로 똑같이 순회해주다가 자식이 없는 2를 만나요.\n",["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250622145326.png","alt":""}],"\n반환값: 1, 4, 3, 2"]}]
54:["$","p",null,{"children":["거슬러 올라가서 가장 최근의 노드중 오른쪽 자식인 5를 순회합니다.\n",["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250622145418.png","alt":""}],"\n반환값: 1, 4, 3, 2, 5"]}]
55:["$","p",null,{"children":["이 방식으로 전체 트리를 순회하면 됩니다.\n",["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250622145427.png","alt":""}],"\n반환값: 1, 4, 3, 2, 5, 8, 7, 6"]}]
56:["$","p",null,{"children":"이 방식으로 순회할 경우 현재 노드를 우선 방문(출력)하기 때문에 직관적으로 이해하기 쉬워요. 트리를 복사할 때 많이 사용하는 방식입니다."}]
57:["$","h2",null,{"id":12,"className":"hltr-orange","children":"중위 순회"}]
58:["$","p",null,{"children":"왼쪽 자식 노드 > 현재 노드 > 오른쪽 자식 노드 순서로 방문합니다. 현재 노드를 거치기만 하고 왼쪽 노드로 내려가는 방식이에요."}]
59:["$","p",null,{"children":"전위 순회랑 똑같은 트리를 순회해볼게요."}]
5a:["$","p",null,{"children":["값이 1인 루트부터 시작해서 왼쪽 자식의 끝 노드까지 가요. 이때 \"방문\"하지 않기 때문에 2만 반환됩니다.\n",["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250622150201.png","alt":""}],"\n반환값: 2"]}]
5b:["$","p",null,{"children":["왼쪽 자식 > 현재 노드 > 오른쪽 자식 순서이기 때문에 2 (3의 왼쪽 자식이었던) 에서 거슬러 올라가서 3을 순회합니다.\n",["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250622150244.png","alt":""}],"\n반환값: 2, 3"]}]
5c:["$","p",null,{"children":["이 방식으로 루트까지 거슬러 올라갑니다.\n",["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250622152000.png","alt":""}],"\n반환값: 2, 3, 4, 5, 1"]}]
5d:["$","p",null,{"children":["다시 왼쪽 노드, 현재 노드, 오른쪽 노드 방식을 재귀하면서 순회를 완료해요.\n",["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250622152148.png","alt":""}],"\n반환값: 2, 3, 4, 5, 1, 8, 6, 7"]}]
5e:["$","p",null,{"children":"추가 정보로 이 방식은 뒤에 나올 이진 탐색 트리에서 정렬된 순서대로 값을 가져올 때 활용되니 잘 알아두셔야 합니다."}]
5f:["$","h2",null,{"id":13,"className":"hltr-orange","children":"후위 순회"}]
60:["$","p",null,{"children":"마지막 순회 방식이에요."}]
61:["$","p",null,{"children":"왼쪽 자식 노드 > 오른쪽 자식 노드 > 현재 노드 순서로 방문합니다."}]
62:["$","p",null,{"children":["규칙에 따라 중위 순회와 똑같이 왼쪽 자식의 끝으로 가요. 2의 왼쪽 자식, 오른쪽 자식은 없기 때문에 현재 노드인 2를 방문합니다.\n",["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250622152402.png","alt":""}],"\n반환값: 2"]}]
63:["$","p",null,{"children":["거슬러 올라가는 건 중위순회와 같지만 4에서 조금 바뀝니다. 4는 왼쪽 자식, 오른쪽 자식 둘다 있는 노드에요. 즉 왼쪽 자식인 3이 방문되었다면 다음 순서는 오른쪽 자식이죠. 즉 4 전에 5가 방문됩니다.\n",["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250622152456.png","alt":""}],"\n반환값: 2, 3, 5"]}]
64:["$","p",null,{"children":["위 현상은 루트에서도 똑같이 일어납니다.\n",["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250622152626.png","alt":""}],"\n반환값: 2, 3, 5, 4, 6"]}]
65:["$","p",null,{"children":["마지막에 루트가 방문되면 순회가 끝나게 됩니다.\n",["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250622152729.png","alt":""}],"\n반환값: 2, 3, 5, 4, 6, 7, 8, 1"]}]
66:["$","p",null,{"children":"노드를 삭제할 때는 부모를 먼저 삭제하면 안되는데요. 자식 노드부터 삭제해야 트리를 유지하면서 재귀로 루트 노드까지 삭제할 수 있기 때문이죠. 그래서 자식 노드부터 방문한다는 후휘 순회의 특성은 트리 삭제에 자주 활용된다고 해요."}]
67:["$","h1",null,{"id":14,"className":"hltr-red","children":"이진 탐색 트리"}]
68:["$","p",null,{"children":"데이터 크기를 따져서 현재 노드보다 값이 작으면 왼쪽 자식 위치에, 크거나 같으면 오른쪽 자식 위치에 배치하는 독특한 정렬 방식을 가진 이진 트리"}]
69:["$","h2",null,{"id":15,"className":"hltr-orange","children":"이진 트리 탐색하기"}]
6a:["$","p",null,{"children":"트리의 좋은 점은 탐색을 효율적으로 하도록 설계할 수 있다는 것입니다."}]
6b:["$","p",null,{"children":"자식 노드가 최대 2개인 이진 트리에 특정 규칙을 부여해서 목적에 맞게 사용할 수 있습니다. 그 중 하나인 이진 탐색 트리에 대해서 알아봅시다."}]
6c:["$","p",null,{"children":"이진 탐색 트리의 규칙은 \"데이터 크기를 따져서 현재 노드보다 값이 작으면 왼쪼 자식 위치에, 크거나 같으면 오른쪽 자식 위치에 배치한다.\" 입니다."}]
6d:["$","p",null,{"children":"다음의 배열을 이진 탐색 트리에 넣어봅시다."}]
6e:["$","pre",null,{"children":["$","code",null,{"className":"hljs language-ts","children":[["$","span",null,{"className":"hljs-keyword","children":"const"}]," arr = [",["$","span",null,{"className":"hljs-number","children":"3"}],", ",["$","span",null,{"className":"hljs-number","children":"4"}],", ",["$","span",null,{"className":"hljs-number","children":"2"}],", ",["$","span",null,{"className":"hljs-number","children":"8"}],", ",["$","span",null,{"className":"hljs-number","children":"9"}],", ",["$","span",null,{"className":"hljs-number","children":"7"}],", ",["$","span",null,{"className":"hljs-number","children":"1"}],"];\n"]}]}]
6f:["$","p",null,{"children":["첫 데이터는 루트 노드가 됩니다. 3만이 존재하는 트리가 되요.\n",["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250622153638.png","alt":""}]]}]
70:["$","p",null,{"children":["이제 이를 기준으로 값이 작으면 왼쪽 값이 크면 오른쪽에 둡니다. 4는 3보다 크니 오른쪽에 둬야 해요.\n",["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250622153724.png","alt":""}]]}]
71:["$","p",null,{"children":["이 방식은 재귀적으로 일어나요. 3, 4, 2 까지는 3을 기준으로 위치가 정해졌다면 8부터는 3 > 4 순서로 규칙이 재귀적으로 적용됩니다. ( 무조건 세번째 값부터라던지 그런 규칙이 아니에요. 3의 두 자식 위치가 다 찼기 때문에 8부터 재귀적으로 적용된겁니다. )\n",["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250622153743.png","alt":""}]]}]
72:["$","p",null,{"children":["이 방식을 통해 최종적으로 이진 탐색 트리를 완성하면 다음과 같아요.\n",["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250622153949.png","alt":""}]]}]
73:["$","p",null,{"children":"이제 이 트리를 기반으로 탐색을 하면 다음의 순서로 할 수 있어요."}]
74:["$","ol",null,{"children":["\n",["$","li",null,{"children":"루트부터 시작해서 값이 작으면 왼쪽 자식 노드로, 값이 크면 오른쪽 자식 노드로 이동한다."}],"\n",["$","li",null,{"children":"특정 값을 찾으면 탐색을 종료한다."}],"\n"]}]
75:["$","p",null,{"children":"위의 간단한 규칙으로 찾을 수 있어서 굉장히 효율적인 것을 계산하지 않아도 알 수 있겠죠. 자세한 시간 복잡도는 뒤에서 다루겠습니다."}]
76:["$","h3",null,{"id":16,"className":"hltr-yellow","children":"배열 탐색과의 차이"}]
77:["$","p",null,{"children":["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250622154332.png","alt":""}]}]
78:["$","p",null,{"children":"위 상황에서 배열에서는 5를 탐색한다고 했을 때 이를 찾기 위해 7번의 비교 연산이 필요해요. 나올 때까지 배열을 순회해야 하기 때문인데요."}]
79:["$","p",null,{"children":"이진 탐색 트리로 같은 상황에서 찾으면 단 2번 만에 탐색이 종료됩니다. ( 탐색하는 인덱스 순서: 0 > 2 > 5, 인덱스 5의 왼쪽 자식이 없으므로 5가 없다는 것을 확인할 수 있어요. )"}]
7a:["$","h3",null,{"id":17,"className":"hltr-yellow","children":"이진 탐색 트리의 시간 복잡도"}]
7b:["$","p",null,{"children":"이진 탐색 트리의 시간 복잡도는 트리 균형에 의존합니다. 균형이 잡힌 트리는 각 노드의 차수가 비슷하게 유지되면서 각 노드의 자식 노드 수가 비슷하게 유지되는 것을 말하는 데요."}]
7c:["$","p",null,{"children":["균형이 유지될 경우 가장 이상적이라고 할 수 있습니다. 가장 이상적일 때의 시간 복잡도는 ",["$","strong",null,{"children":"O(logN)"}]," 입니다. ( 삽입, 탐색 때 추적 대상이 정확히 반씩 줄어들기 때문이에요. )"]}]
7d:["$","p",null,{"children":["반대로 균형이 유지 되지 않았다면 삽입과 탐색 연산 시 ",["$","strong",null,{"children":"O(N)"}]," 의 시간복잡도를 가져요. 이는 배열과 일치하죠."]}]
7e:["$","p",null,{"children":"어떤 이유인지 알아봅시다."}]
7f:["$","h4",null,{"id":18,"className":"hltr-green","children":"비균형적인 트리: 치우쳐진 형태의 트리"}]
80:["$","p",null,{"children":["degenerate binary tree\n",["$","img",null,{"src":"/images/2025-06-21/Pasted%20image%2020250622155353.png","alt":""}]]}]
81:["$","p",null,{"children":"이진 탐색 트리의 규칙은 현재 찾고 싶은 값이 현재 탐색하고 있는 값보다 작으면 그 왼쪽 자식을 탐색하고 아니면 오른쪽 자식, 같으면 탐색을 종료하는 것입니다."}]
82:["$","p",null,{"children":"비균형적이면 위 규칙이 필요없는 경우가 많아지겠죠. 한 방향으로만 갈테니까요. 극단적으로 생각하면 이는 배열과 별 다를 게 없는 구조가 됩니다. 즉 시간 복잡도도 배열과 같이 O(N)을 갖는 것이지요."}]
83:["$","p",null,{"children":"하지만 이는 수많은 경우 중에 한 경우에요. 만약 위 그림에서 하나라도 루트 노드의 반대쪽 자식으로 이동한다면 배열보다는 성능이 좋다고 할 수 있겠죠."}]
84:["$","h4",null,{"id":19,"className":"hltr-green","children":"균형적인 트리: 균형 이진 탐색 트리"}]
85:["$","p",null,{"children":"균형 이진 탐색 트리는 세부적으로 AVL 트리, 레드-블랙 트리 등으로 구분하여 부르곤 합니다. 이를 활용하면 탐색 연산 횟수가 트리 높이에 비례하고 트리의 높이는 logN이므로 탐색 시간 복잡도를 O(logN)으로 유지할 수 있습니다."}]
86:["$","h1",null,{"id":20,"className":"hltr-red","children":"참고 문헌"}]
87:["$","p",null,{"children":["$","a",null,{"href":"https://product.kyobobook.co.kr/detail/S000213641007","children":"https://product.kyobobook.co.kr/detail/S000213641007"}]}]
88:["$","blockquote",null,{"className":"bg-quote-gray border-gray-500 rounded-xl border-y border-r border-y-gray-400 border-r-gray-400 border-opacity-30 p-4 not-italic","children":[["$","div",null,{"className":"text-gray-500 flex items-center gap-1 text-lg font-bold md:text-2xl","children":[["$","svg",null,{"ref":"$undefined","xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-notepad-text","children":[["$","path","1cmpym",{"d":"M8 2v4"}],["$","path","3427ic",{"d":"M12 2v4"}],["$","path","4m81vk",{"d":"M16 2v4"}],["$","rect","1u9h20",{"width":"16","height":"18","x":"4","y":"4","rx":"2"}],["$","path","3oa6kw",{"d":"M8 10h6"}],["$","path","1fgep2",{"d":"M8 14h8"}],["$","path","17enja",{"d":"M8 18h5"}],"$undefined"]}],["$","div",null,{"children":"SUMMARY"}]]}],["$","section",null,{"className":"text-sm font-semibold text-black md:text-base","children":["\n",["$","p",null,{"children":"알고리즘은 꾸준히 공부해주지 않으면 개념들이 유독 빠르게 사라지는 것 같아요.\n사라지면 다시 채워넣을 수 있도록 꾸준히 공부해보겠습니다.\n잘못된 지식이 있다면 댓글 부탁드려요!"}],"\n",["$","p",null,{"children":"읽어주셔서 감사해요."}],"\n"]}]]}]
